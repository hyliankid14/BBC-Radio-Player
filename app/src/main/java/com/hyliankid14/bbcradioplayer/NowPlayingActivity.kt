package com.hyliankid14.bbcradioplayer

import android.content.Intent
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.widget.ImageView
import android.widget.SeekBar
import android.widget.TextView
import android.text.method.ScrollingMovementMethod
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.bumptech.glide.Glide
import com.bumptech.glide.load.DataSource
import com.bumptech.glide.load.engine.GlideException
import com.bumptech.glide.request.RequestListener
import com.bumptech.glide.request.target.Target
import com.google.android.material.button.MaterialButton
import android.content.res.ColorStateList
import com.hyliankid14.bbcradioplayer.PodcastSubscriptions
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.Locale
import android.view.View

class NowPlayingActivity : AppCompatActivity() {
    private lateinit var stationArtwork: ImageView
    private lateinit var showName: TextView
    private lateinit var episodeTitle: TextView
    private lateinit var artistTrack: TextView
    private lateinit var releaseDateView: TextView
    private lateinit var showMoreLink: TextView
    private lateinit var stopButton: MaterialButton
    private lateinit var previousButton: MaterialButton
    private lateinit var playPauseButton: MaterialButton
    private lateinit var nextButton: MaterialButton
    private lateinit var favoriteButton: MaterialButton
    private lateinit var seekBar: SeekBar
    private lateinit var progressGroup: android.view.View
    private lateinit var elapsedView: TextView
    private lateinit var remainingView: TextView
    private lateinit var markPlayedButton: android.widget.ImageButton
    private var currentShownEpisodeId: String? = null
    private var matchedPodcast: Podcast? = null
    // Track the async job/generation for finding matching podcasts to avoid flicker
    private var openPodcastJob: kotlinx.coroutines.Job? = null
    private var openPodcastGeneration: Int = 0
    private var lastOpenPodcastStationId: String? = null

    // When true the activity is showing a preview episode passed via intent and should not be
    // overwritten by subsequent playback state updates until playback starts.
    private var isPreviewMode = false
    private var previewEpisodeProp: Episode? = null
    
    private var updateTimer: Thread? = null
    private var lastArtworkUrl: String? = null
    // Store raw HTML for the full description so the dialog can render the complete content
    private var fullDescriptionHtml: String = ""
    private val showChangeListener: (CurrentShow) -> Unit = { show ->
        runOnUiThread { updateFromShow(show) }
    }

    private fun findMatchingPodcastAsync(station: Station?, show: CurrentShow, generation: Int) {
        // Cancel any previous job for finding an open podcast match
        openPodcastJob?.cancel()
        openPodcastJob = lifecycleScope.launch {
            try {
                // Only attempt when we have a radio station (not a podcast) and a non-empty show title
                if (station == null || station.id.startsWith("podcast_") || show.title.isBlank()) return@launch

                val repo = PodcastRepository(this@NowPlayingActivity)
                val podcasts = withContext(Dispatchers.IO) { repo.fetchPodcasts(false) }
                val queries = listOfNotNull(
                    show.title.takeIf { it.isNotEmpty() },
                    show.episodeTitle?.takeIf { it.isNotEmpty() },
                    station.title.takeIf { it.isNotEmpty() }
                )
                // Only accept exact title match (case-insensitive). Do NOT fall back to approximate matching here.
                var found: Podcast? = null
                for (q in queries) {
                    found = podcasts.find { it.title.equals(q, ignoreCase = true) }
                    if (found != null) break
                }

                // Ensure the result is still relevant for the current generation and station
                if (generation == openPodcastGeneration) {
                    val currentStationId = PlaybackStateHelper.getCurrentStation()?.id
                    if (found != null && currentStationId == station.id && !station.id.startsWith("podcast_")) {
                        matchedPodcast = found
                        lastOpenPodcastStationId = station.id
                        findViewById<MaterialButton>(R.id.now_playing_open_podcast).visibility = View.VISIBLE
                    } else {
                        // No exact match — ensure button is hidden and any previous match cleared
                        matchedPodcast = null
                        findViewById<MaterialButton>(R.id.now_playing_open_podcast).visibility = View.GONE
                    }
                }
            } catch (e: Exception) {
                android.util.Log.w("NowPlayingActivity", "Failed to find matching podcast: ${e.message}")
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_now_playing)

        // Setup action bar with back button using Material Top App Bar
        val toolbar = findViewById<com.google.android.material.appbar.MaterialToolbar?>(R.id.top_app_bar)
        toolbar?.let { setSupportActionBar(it) }
        supportActionBar?.setDisplayHomeAsUpEnabled(true)

        // Initialize views
        stationArtwork = findViewById(R.id.now_playing_artwork)
        showName = findViewById(R.id.now_playing_show_name)
        episodeTitle = findViewById(R.id.now_playing_episode_title)
        artistTrack = findViewById(R.id.now_playing_artist_track)
        releaseDateView = findViewById(R.id.now_playing_release_date)
        showMoreLink = findViewById(R.id.now_playing_show_more)
        stopButton = findViewById(R.id.now_playing_stop)
        previousButton = findViewById(R.id.now_playing_previous)
        playPauseButton = findViewById(R.id.now_playing_play_pause)
        nextButton = findViewById(R.id.now_playing_next)
        favoriteButton = findViewById(R.id.now_playing_favorite)
        progressGroup = findViewById(R.id.podcast_progress_group)
        seekBar = findViewById(R.id.playback_seekbar)
        elapsedView = findViewById(R.id.playback_elapsed)
        remainingView = findViewById(R.id.playback_remaining)
        markPlayedButton = findViewById(R.id.now_playing_mark_played) 

        // Setup control button listeners
        stopButton.setOnClickListener { stopPlayback() }
        previousButton.setOnClickListener { skipToPrevious() }
        playPauseButton.setOnClickListener {
            // If we're previewing an episode (opened from list), start playback of that episode
            val preview = previewEpisodeProp
            if (isPreviewMode && preview != null) {
                playEpisodePreview(preview)
            } else {
                togglePlayPause()
            }
        }
        nextButton.setOnClickListener { skipToNext() }
        favoriteButton.setOnClickListener { toggleFavorite() }
        showMoreLink.setOnClickListener { showFullDescription() }
        artistTrack.setOnClickListener { showFullDescription() }

        // Mark-as-played button (manual toggle)
        // Hidden by design to avoid duplication with subscription controls in the app bar
        markPlayedButton.visibility = android.view.View.GONE
        // (Intentional: keep logic available if needed later, but do not assign a click listener.)

        // Open podcast button (initially hidden). Will be shown when a matching podcast is found for current show.
        val openPodcastButton: MaterialButton = findViewById(R.id.now_playing_open_podcast)
        openPodcastButton.visibility = android.view.View.GONE
        openPodcastButton.setOnClickListener {
            matchedPodcast?.let { p ->
                // Navigate back to MainActivity and open the podcast detail
                val intent = Intent(this, MainActivity::class.java).apply {
                    addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
                    putExtra("open_podcast_id", p.id)
                }
                startActivity(intent)
                finish()
            }
        }


        seekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
                if (fromUser) {
                    val show = PlaybackStateHelper.getCurrentShow()
                    val duration = show.segmentDurationMs ?: return
                    if (duration <= 0) return
                    val newPos = (duration * (progress / seekBar!!.max.toDouble())).toLong()
                    sendSeekTo(newPos)
                }
            }

            override fun onStartTrackingTouch(seekBar: SeekBar?) {}

            override fun onStopTrackingTouch(seekBar: SeekBar?) {}
        })

        // Register listener for show changes
        PlaybackStateHelper.onShowChange(showChangeListener)

        // Handle back navigation using the modern OnBackPressedDispatcher
        onBackPressedDispatcher.addCallback(this, object : androidx.activity.OnBackPressedCallback(true) {
            override fun handleOnBackPressed() {
                val hasPodcastContext = previewEpisodeProp != null
                        || !intent.getStringExtra("initial_podcast_id").isNullOrEmpty()
                        || PlaybackStateHelper.getCurrentStation()?.id?.startsWith("podcast_") == true

                if (hasPodcastContext) {
                    navigateBackToPodcastDetail()
                    return
                }

                if (isTaskRoot) {
                    val intent = Intent(this@NowPlayingActivity, MainActivity::class.java).apply {
                        addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
                    }
                    startActivity(intent)
                    finish()
                } else {
                    // Fall through to default behavior
                    isEnabled = false
                    onBackPressedDispatcher.onBackPressed()
                }
            }
        })
        
        // If we're opened in preview mode for an episode (no playback), show that episode's details
        val previewEpisode: Episode? = intent.getParcelableExtraCompat<Episode>("preview_episode", Episode::class.java)
        if (previewEpisode != null) {
            isPreviewMode = true
            previewEpisodeProp = previewEpisode
            val previewPodcastTitle = intent.getStringExtra("preview_podcast_title")
            val previewPodcastImage = intent.getStringExtra("preview_podcast_image")
            showPreviewEpisode(previewEpisode, previewPodcastTitle, previewPodcastImage)
            // If caller asked us to present the preview using the same playing UI (but without autoplay),
            // make small adjustments so the screen matches the playing UI more closely.
            val usePlayUi = intent.getBooleanExtra("preview_use_play_ui", false)
            if (usePlayUi) {
                // Ensure play button shows play icon (not autoplay)
                playPauseButton.icon = ContextCompat.getDrawable(this, R.drawable.ic_play_arrow)
                // Keep progress controls visible if duration present (already handled in showPreviewEpisode)
                // Ensure action bar title is set from provided podcast title
                val initialTitle = intent.getStringExtra("initial_podcast_title")
                if (!initialTitle.isNullOrEmpty()) supportActionBar?.title = initialTitle
            }
        }

        // If an initial podcast image/title is provided (launched immediately after starting playback),
        // show it so artwork is visible while playback state initializes.
        val initialImage: String? = intent.getStringExtra("initial_podcast_image")
        val initialTitle: String? = intent.getStringExtra("initial_podcast_title")
        if (!initialImage.isNullOrEmpty()) {
            Glide.with(this).load(initialImage).into(stationArtwork)
            lastArtworkUrl = initialImage
        }
        if (!initialTitle.isNullOrEmpty()) {
            supportActionBar?.title = initialTitle
        }

        // If opened in preview for a specific episode with a podcast id, show the open podcast button only when a radio station is playing
        val openPodcastButtonInit: MaterialButton? = findViewById(R.id.now_playing_open_podcast)
        val previewPodcastId = previewEpisodeProp?.podcastId ?: intent.getStringExtra("initial_podcast_id")
        if (!previewPodcastId.isNullOrEmpty()) {
            // Try to find podcast in cache quickly
            lifecycleScope.launch {
                val repo = PodcastRepository(this@NowPlayingActivity)
                val pods = withContext(Dispatchers.IO) { repo.fetchPodcasts(false) }
                val found = pods.find { it.id == previewPodcastId }
                if (found != null) {
                    val currentStation = PlaybackStateHelper.getCurrentStation()
                    val currentShowTitle = PlaybackStateHelper.getCurrentShow().title
                    // Only show the button when there is an active radio station (not a podcast) playing
                    // AND the currently playing show's title exactly matches the podcast series title.
                    if (currentStation != null && !currentStation.id.startsWith("podcast_")
                        && currentShowTitle.equals(found.title, ignoreCase = true)
                    ) {
                        matchedPodcast = found
                        openPodcastButtonInit?.visibility = View.VISIBLE
                    } else {
                        matchedPodcast = null
                        openPodcastButtonInit?.visibility = View.GONE
                    }

                    // If preview artwork is missing or is the generic placeholder, prefer the series image
                    try {
                        val previewArtworkMissing = lastArtworkUrl.isNullOrEmpty() || lastArtworkUrl!!.contains("icon-apple-podcast.png")
                        if (previewArtworkMissing && !found.imageUrl.isNullOrEmpty()) {
                            lastArtworkUrl = found.imageUrl
                            runOnUiThread {
                                Glide.with(this@NowPlayingActivity)
                                    .load(lastArtworkUrl)
                                    .into(stationArtwork)
                            }
                        }
                    } catch (e: Exception) {
                        android.util.Log.w("NowPlayingActivity", "Failed to apply series artwork: ${e.message}")
                    }
                }
            }
        }

        // Ensure mark button reflects current episode if preview provided
        previewEpisodeProp?.let { currentShownEpisodeId = it.id }
        updateMarkPlayedButtonState()

        // Initial update only when not in preview mode
        if (!isPreviewMode) updateUI()
        
        // Start polling for playback state updates
        startPlaybackStateUpdates()
    }

    override fun onSupportNavigateUp(): Boolean {
        // If we were opened for a specific podcast (preview or provided initial id) or the current
        // playback station is a podcast, prefer navigating back to the podcast detail screen.
        val hasPodcastContext = previewEpisodeProp != null
                || !intent.getStringExtra("initial_podcast_id").isNullOrEmpty()
                || PlaybackStateHelper.getCurrentStation()?.id?.startsWith("podcast_") == true

        if (hasPodcastContext) {
            navigateBackToPodcastDetail()
            return true
        }

        if (isTaskRoot) {
            // No previous activity in the task — go to MainActivity without forcing a specific podcast
            val intent = Intent(this, MainActivity::class.java).apply {
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            }
            startActivity(intent)
            finish()
            return true
        } else {
            // Let the system handle navigation when there is a previous activity
            finish()
            return true
        }
    }

    // Back navigation handled by OnBackPressedDispatcher callback (added in onCreate).

    private fun navigateBackToPodcastDetail() {
        // Prefer the explicit preview episode's podcastId when available, otherwise derive from current station
        val podcastId = previewEpisodeProp?.podcastId ?: PlaybackStateHelper.getCurrentStation()?.id?.removePrefix("podcast_")
        if (!podcastId.isNullOrEmpty()) {
            val intent = Intent(this, MainActivity::class.java).apply {
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
                putExtra("open_podcast_id", podcastId)
            }
            startActivity(intent)
            finish()
            return
        }

        // If we're showing a radio station (not a podcast), return to the list where the station was opened from
        val station = PlaybackStateHelper.getCurrentStation()
        if (station != null && !station.id.startsWith("podcast_")) {
            val origin = intent.getStringExtra("origin_mode") ?: "list"
            val intent = Intent(this, MainActivity::class.java).apply {
                addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP)
                putExtra("open_mode", if (origin == "favorites") "favorites" else "list")
            }
            startActivity(intent)
            finish()
            return
        }

        // Fallback to default behaviour
        finish()
    }

    override fun onResume() {
        super.onResume()
        startPlaybackStateUpdates()
        updateUI()
    }

    override fun onPause() {
        super.onPause()
        stopPlaybackStateUpdates()
    }

    override fun onDestroy() {
        super.onDestroy()
        PlaybackStateHelper.removeShowChangeListener(showChangeListener)
        stopPlaybackStateUpdates()
    }

    private fun updateUI() {
        if (isFinishing || isDestroyed) return
        // Don't overwrite preview UI when in preview mode
        if (isPreviewMode) return
        val station = PlaybackStateHelper.getCurrentStation()
        val isPlaying = PlaybackStateHelper.getIsPlaying()
        val show = PlaybackStateHelper.getCurrentShow()
        val isPodcast = station?.id?.startsWith("podcast_") == true

        // Hide the open-podcast button while playing a podcast
        if (isPodcast) {
            matchedPodcast = null
            findViewById<MaterialButton?>(R.id.now_playing_open_podcast)?.visibility = View.GONE
            lastOpenPodcastStationId = null
        }

        val currentStationId = station?.id
        if (lastOpenPodcastStationId != currentStationId) {
            // Station changed, clear previous match and hide button
            matchedPodcast = null
            findViewById<MaterialButton?>(R.id.now_playing_open_podcast)?.visibility = View.GONE
            lastOpenPodcastStationId = null
        }

        // Only update the main UI when we have a valid station; otherwise hide controls
        if (station != null) {
            // Only attempt to find matches for radio stations (not podcasts) and when there's a show title
            if (!isPodcast && show.title.isNotBlank()) {
                openPodcastGeneration += 1
                findMatchingPodcastAsync(station, show, openPodcastGeneration)
            }
            if (isPodcast) {
                // Podcasts: action bar already shows podcast name; hide duplicate header
                showName.visibility = android.view.View.GONE

                val episodeHeading = show.episodeTitle?.takeIf { it.isNotEmpty() } ?: show.title
                if (!episodeHeading.isNullOrEmpty()) {
                    episodeTitle.text = episodeHeading
                    episodeTitle.visibility = android.view.View.VISIBLE
                } else {
                    episodeTitle.visibility = android.view.View.GONE
                }

                val rawDesc = show.description ?: ""
                if (rawDesc.isNotEmpty()) {
                    // Keep raw HTML for the full screen dialog
                    fullDescriptionHtml = rawDesc
                    // Render a spanned preview in the small area so formatting is preserved
                    val spanned = androidx.core.text.HtmlCompat.fromHtml(rawDesc, androidx.core.text.HtmlCompat.FROM_HTML_MODE_LEGACY)

                    // Avoid showing the same text twice: hide `artistTrack` when the description
                    // is effectively identical to the episode heading/title shown above.
                    val episodeHeading = show.episodeTitle?.takeIf { it.isNotEmpty() } ?: show.title
                    val descPlain = spanned.toString().trim()
                    if (descPlain.isNotEmpty() && !episodeHeading.isNullOrEmpty() && !descPlain.equals(episodeHeading.trim(), ignoreCase = true)) {
                        artistTrack.text = spanned
                        artistTrack.maxLines = 4
                        artistTrack.ellipsize = android.text.TextUtils.TruncateAt.END
                        artistTrack.visibility = android.view.View.VISIBLE
                        // Check if description exceeds 4 lines
                        artistTrack.post {
                            if (artistTrack.lineCount > 4) {
                                showMoreLink.visibility = android.view.View.VISIBLE
                            } else {
                                showMoreLink.visibility = android.view.View.GONE
                            }
                        }
                    } else {
                        artistTrack.visibility = android.view.View.GONE
                        showMoreLink.visibility = android.view.View.GONE
                    }
                } else {
                    artistTrack.visibility = android.view.View.GONE
                    showMoreLink.visibility = android.view.View.GONE
                }
            } else {
                // Radio: show name plus subtitle/song metadata
                showName.visibility = android.view.View.VISIBLE
                showName.text = show.title.ifEmpty { "BBC Radio" }
                // Ensure the action bar shows the radio station name
                supportActionBar?.title = station.title

                // Prefer showing the show's "subtitle" (secondary/tertiary) in the large headline
                val subtitle = listOfNotNull(show.secondary?.takeIf { it.isNotBlank() }, show.tertiary?.takeIf { it.isNotBlank() }).joinToString(" - ").takeIf { it.isNotBlank() }
                val songTitle = show.episodeTitle?.takeIf { it.isNotBlank() }

                if (!subtitle.isNullOrEmpty()) {
                    episodeTitle.text = subtitle
                    episodeTitle.visibility = android.view.View.VISIBLE
                } else if (!songTitle.isNullOrEmpty()) {
                    // Fallback: use the episode title if no subtitle is available
                    episodeTitle.text = songTitle
                    episodeTitle.visibility = android.view.View.VISIBLE
                } else {
                    episodeTitle.visibility = android.view.View.GONE
                }

                // Per product request: never show the smaller subtitle line for live radio —
                // keep the full-screen surface clean. (Music segments will still surface
                // Artist - Track in the large headline when available.)
                artistTrack.visibility = android.view.View.GONE
                showMoreLink.visibility = android.view.View.GONE
            }
            
            // Load artwork: Use image_url from API if available and valid, otherwise station logo
            val artworkUrl = if (!show.imageUrl.isNullOrEmpty() && show.imageUrl.startsWith("http")) {
                show.imageUrl
            } else {
                station.logoUrl
            }
            
            // Only reload if URL changed
            if (artworkUrl != lastArtworkUrl && !isFinishing && !isDestroyed) {
                lastArtworkUrl = artworkUrl
                val fallbackUrl = station.logoUrl
                
                Glide.with(this)
                    .load(artworkUrl)
                    .placeholder(android.R.color.transparent)
                    .error(Glide.with(this).load(fallbackUrl))
                    .listener(object : RequestListener<Drawable> {
                        override fun onLoadFailed(e: GlideException?, model: Any?, target: Target<Drawable>?, isFirstResource: Boolean): Boolean {
                            return false
                        }

                        override fun onResourceReady(resource: Drawable?, model: Any?, target: Target<Drawable>?, dataSource: DataSource?, isFirstResource: Boolean): Boolean {
                            if (resource is BitmapDrawable && isPlaceholderImage(resource.bitmap)) {
                                stationArtwork.post {
                                    Glide.with(this@NowPlayingActivity)
                                        .load(fallbackUrl)
                                        .into(stationArtwork)
                                }
                                return true
                            }
                            return false
                        }
                    })
                    .into(stationArtwork)
            }
            
            updateProgressUi()

            // Update play/pause button
            playPauseButton.icon = ContextCompat.getDrawable(this, if (isPlaying) R.drawable.ic_pause else R.drawable.ic_play_arrow)
            
            val podcastId = station.id.removePrefix("podcast_")
            // If we're playing a podcast episode, show bookmark (episode save). Otherwise keep existing star semantics
            val currentEpisodeId = PlaybackStateHelper.getCurrentEpisodeId()

            // Show release date for podcast episodes (cache-first, background fetch if necessary)
            if (isPodcast) {
                fetchAndShowEpisodePubDate(podcastId, currentEpisodeId)
            } else {
                releaseDateView.visibility = View.GONE
            }

            if (isPodcast && !currentEpisodeId.isNullOrEmpty()) {
                val saved = SavedEpisodes.isSaved(this, currentEpisodeId)
                favoriteButton.icon = ContextCompat.getDrawable(this, if (saved) R.drawable.ic_bookmark else R.drawable.ic_bookmark_outline)
                favoriteButton.iconTint = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.md_theme_primary))
                favoriteButton.setBackgroundColor(if (saved) ContextCompat.getColor(this, R.color.md_theme_primaryContainer) else android.graphics.Color.TRANSPARENT)
            } else {
                val isFavorited = if (isPodcast) {
                    PodcastSubscriptions.isSubscribed(this, podcastId)
                } else {
                    FavoritesPreference.isFavorite(this, station.id)
                }
                favoriteButton.icon = ContextCompat.getDrawable(this, if (isFavorited) R.drawable.ic_star_filled else R.drawable.ic_star_outline)
                favoriteButton.iconTint = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.md_theme_primary))
                favoriteButton.setBackgroundColor(if (isFavorited) ContextCompat.getColor(this, R.color.md_theme_primaryContainer) else android.graphics.Color.TRANSPARENT)
            }
        } else {
            progressGroup.visibility = android.view.View.GONE
            seekBar.visibility = android.view.View.GONE
        }
    }

    private fun showPreviewEpisode(episode: Episode, podcastTitle: String?, podcastImage: String?) {
        // Ensure action bar shows the podcast name while previewing
        supportActionBar?.title = podcastTitle ?: supportActionBar?.title
        // Display podcast title or provided podcastTitle
        showName.visibility = android.view.View.GONE

        val episodeHeading = episode.title
        episodeTitle.text = episodeHeading
        episodeTitle.visibility = android.view.View.VISIBLE

        val rawDesc = episode.description
        if (rawDesc.isNotEmpty()) {
            fullDescriptionHtml = rawDesc
            val spanned = androidx.core.text.HtmlCompat.fromHtml(rawDesc, androidx.core.text.HtmlCompat.FROM_HTML_MODE_LEGACY)
            // Avoid showing the same text twice when the description is just the episode title
            val descPlain = spanned.toString().trim()
            if (!descPlain.equals(episode.title.trim(), ignoreCase = true)) {
                artistTrack.text = spanned
                artistTrack.maxLines = 4
                artistTrack.ellipsize = android.text.TextUtils.TruncateAt.END
                artistTrack.visibility = android.view.View.VISIBLE
                artistTrack.post {
                    if (artistTrack.lineCount > 4) {
                        showMoreLink.visibility = android.view.View.VISIBLE
                    } else {
                        showMoreLink.visibility = android.view.View.GONE
                    }
                }
            } else {
                artistTrack.visibility = android.view.View.GONE
                showMoreLink.visibility = android.view.View.GONE
            }
        } else {
            artistTrack.visibility = android.view.View.GONE
            showMoreLink.visibility = android.view.View.GONE
        }

        // Load artwork from episode or podcast image if provided
        val artworkUrl = episode.imageUrl.takeIf { it.isNotEmpty() } ?: podcastImage
        if (!artworkUrl.isNullOrEmpty()) {
            Glide.with(this).load(artworkUrl).into(stationArtwork)
            lastArtworkUrl = artworkUrl
        }

        // Store preview episode so play button can start it
        previewEpisodeProp = episode
        currentShownEpisodeId = episode.id

        // Show release date when available (preview contains full Episode)
        if (!episode.pubDate.isNullOrEmpty()) {
            releaseDateView.text = formatEpisodeDate(episode.pubDate)
            releaseDateView.visibility = View.VISIBLE
        } else {
            releaseDateView.visibility = View.GONE
        }

        updateMarkPlayedButtonState()

        // Update favorite button to reflect saved-episode state for the previewed episode (separate from podcast subscriptions)
        try {
            val saved = SavedEpisodes.isSaved(this, episode.id)
            favoriteButton.icon = ContextCompat.getDrawable(this, if (saved) R.drawable.ic_bookmark else R.drawable.ic_bookmark_outline)
            favoriteButton.iconTint = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.md_theme_primary))
            favoriteButton.setBackgroundColor(if (saved) ContextCompat.getColor(this, R.color.md_theme_primaryContainer) else android.graphics.Color.TRANSPARENT)
        } catch (_: Exception) {}

        // Show scrubber controls if episode has a duration so user can see progress
        val durMs = (episode.durationMins.takeIf { it >= 0 } ?: 0) * 60_000L
        if (durMs > 0) {
            progressGroup.visibility = android.view.View.VISIBLE
            seekBar.visibility = android.view.View.VISIBLE
            // Initialize scrubber to start (not playing)
            seekBar.progress = 0
            seekBar.isEnabled = false
            elapsedView.text = "0:00"
            remainingView.text = "-${formatTime(durMs)}"
        } else {
            progressGroup.visibility = android.view.View.GONE
            seekBar.visibility = android.view.View.GONE
        }
    }

    private fun playEpisodePreview(episode: Episode) {
        // Do not clear lastArtworkUrl here — keep the preview artwork visible until the service
        // provides the official station artwork to avoid visual disappearance on play.

        val intent = Intent(this, RadioService::class.java).apply {
            action = RadioService.ACTION_PLAY_PODCAST_EPISODE
            putExtra(RadioService.EXTRA_EPISODE, episode)
            putExtra(RadioService.EXTRA_PODCAST_ID, episode.podcastId)
            // Pass the currently displayed artwork and title (if available) so the service can
            // set a synthetic station logo immediately and avoid flashing a missing image.
            if (!lastArtworkUrl.isNullOrEmpty()) putExtra(RadioService.EXTRA_PODCAST_IMAGE, lastArtworkUrl)
            supportActionBar?.title?.let { putExtra(RadioService.EXTRA_PODCAST_TITLE, it.toString()) }
        }
        startService(intent)
        // Exit preview mode and allow normal updates to take over
        isPreviewMode = false
        previewEpisodeProp = null
        updateUI()
    }

    private fun updateProgressUi() {
        val station = PlaybackStateHelper.getCurrentStation()
        val isPodcast = station?.id?.startsWith("podcast_") == true
        val showProgress = PlaybackStateHelper.getCurrentShow()
        val pos = showProgress.segmentStartMs ?: 0L
        val dur = showProgress.segmentDurationMs ?: 0L

        if (isPodcast && dur > 0) {
            progressGroup.visibility = android.view.View.VISIBLE
            seekBar.visibility = android.view.View.VISIBLE
            val ratio = (pos.toDouble() / dur.toDouble()).coerceIn(0.0, 1.0)
            seekBar.progress = (ratio * seekBar.max).toInt()
            elapsedView.text = formatTime(pos)
            remainingView.text = "-${formatTime((dur - pos).coerceAtLeast(0))}"
            seekBar.isEnabled = true
        } else {
            progressGroup.visibility = android.view.View.GONE
            seekBar.visibility = android.view.View.GONE
        }

        // Ensure mark-played button reflects current playback state
        updateMarkPlayedButtonState()
    }

    private fun sendSeekTo(positionMs: Long) {
        val intent = Intent(this, RadioService::class.java).apply {
            action = RadioService.ACTION_SEEK_TO
            putExtra(RadioService.EXTRA_SEEK_POSITION, positionMs)
        }
        startService(intent)
    }

    private fun formatTime(ms: Long): String {
        val totalSeconds = ms / 1000
        val minutes = totalSeconds / 60
        val seconds = totalSeconds % 60
        return String.format("%d:%02d", minutes, seconds)
    }

    // Cache-first helper: try in-memory episodes, otherwise perform a short background fetch
    private fun fetchAndShowEpisodePubDate(podcastId: String, episodeId: String?) {
        if (episodeId.isNullOrEmpty()) {
            releaseDateView.visibility = View.GONE
            return
        }

        val repo = PodcastRepository(this)
        // Try fast in-memory cache first
        try {
            val cached = repo.getEpisodesFromCache(podcastId)
            val found = cached?.firstOrNull { it.id == episodeId }
            if (found != null && !found.pubDate.isNullOrEmpty()) {
                releaseDateView.text = formatEpisodeDate(found.pubDate)
                releaseDateView.visibility = View.VISIBLE
                return
            }
        } catch (_: Exception) {
            // ignore and fall back to lightweight fetch
        }

        // Background fetch (best-effort, short timeout) — do not block the UI
        lifecycleScope.launch {
            try {
                val pods = withContext(Dispatchers.IO) { repo.fetchPodcasts(false) }
                val pod = pods.firstOrNull { it.id == podcastId }
                if (pod == null) {
                    releaseDateView.visibility = View.GONE
                    return@launch
                }

                val eps = try { withContext(Dispatchers.IO) { repo.fetchEpisodesIfNeeded(pod) } } catch (_: Exception) { emptyList<Episode>() }
                val found = eps.firstOrNull { it.id == episodeId }
                if (found != null && !found.pubDate.isNullOrEmpty()) {
                    runOnUiThread {
                        releaseDateView.text = formatEpisodeDate(found.pubDate)
                        releaseDateView.visibility = View.VISIBLE
                    }
                    return@launch
                }
            } catch (_: Exception) {
                // best-effort only
            }
            runOnUiThread { releaseDateView.visibility = View.GONE }
        }
    }

    // Duplicate of PodcastAdapter.formatEpisodeDate — keep local to avoid touching adapter visibility
    private fun formatEpisodeDate(raw: String): String {
        val patterns = listOf(
            "EEE, dd MMM yyyy HH:mm:ss Z",
            "dd MMM yyyy HH:mm:ss Z",
            "EEE, dd MMM yyyy"
        )
        val parsed: java.util.Date? = patterns.firstNotNullOfOrNull { pattern ->
            try {
                java.text.SimpleDateFormat(pattern, java.util.Locale.US).parse(raw)
            } catch (e: java.text.ParseException) {
                null
            }
        }
        return parsed?.let {
            java.text.SimpleDateFormat("EEE, dd MMM yyyy", java.util.Locale.US).format(it)
        } ?: (if (raw.contains(":")) raw.substringBefore(":").substringBeforeLast(" ").trim() else raw.trim())
    }
    
    private fun updateFromShow(show: CurrentShow) {
        if (isFinishing || isDestroyed) return
        // If we're in preview mode do not override the preview. If playback actually starts (station non-null)
        // we'll clear preview mode and continue handling updates.
        if (isPreviewMode && PlaybackStateHelper.getCurrentStation() == null) return

        val station = PlaybackStateHelper.getCurrentStation()
        val isPodcast = station?.id?.startsWith("podcast_") == true
        
        // Hide the open-podcast button when playback is a podcast
        if (isPodcast) {
            matchedPodcast = null
            findViewById<MaterialButton?>(R.id.now_playing_open_podcast)?.visibility = View.GONE
            lastOpenPodcastStationId = null
        }
        
        if (isPodcast) {
            showName.visibility = android.view.View.GONE

            val episodeHeading = show.episodeTitle?.takeIf { it.isNotEmpty() } ?: show.title
            if (!episodeHeading.isNullOrEmpty()) {
                episodeTitle.text = episodeHeading
                episodeTitle.visibility = android.view.View.VISIBLE
            } else {
                episodeTitle.visibility = android.view.View.GONE
            }

            // Try to surface episode release date when available
            val podcastId = PlaybackStateHelper.getCurrentStation()?.id?.removePrefix("podcast_")
            val currentEpisodeId = PlaybackStateHelper.getCurrentEpisodeId()
            if (!podcastId.isNullOrEmpty()) {
                fetchAndShowEpisodePubDate(podcastId, currentEpisodeId)
            } else {
                releaseDateView.visibility = View.GONE
            }

            val rawDesc = show.description ?: ""
            if (rawDesc.isNotEmpty()) {
                fullDescriptionHtml = rawDesc
                val spanned = androidx.core.text.HtmlCompat.fromHtml(rawDesc, androidx.core.text.HtmlCompat.FROM_HTML_MODE_LEGACY)

                // Hide the small-line if it merely repeats the large episode heading (case-insensitive,
                // trimmed). This prevents the duplicated subtitle seen in the screenshot.
                val smallText = spanned.toString().trim()
                val largeText = (episodeHeading ?: "").trim()
                if (smallText.isNotEmpty() && smallText.equals(largeText, ignoreCase = true)) {
                    artistTrack.visibility = android.view.View.GONE
                    showMoreLink.visibility = android.view.View.GONE
                } else {
                    artistTrack.text = spanned
                    artistTrack.maxLines = 4
                    artistTrack.ellipsize = android.text.TextUtils.TruncateAt.END
                    artistTrack.visibility = android.view.View.VISIBLE
                    // Check if description exceeds 4 lines
                    artistTrack.post {
                        if (artistTrack.lineCount > 4) {
                            showMoreLink.visibility = android.view.View.VISIBLE
                        } else {
                            showMoreLink.visibility = android.view.View.GONE
                        }
                    }
                }
            } else {
                artistTrack.visibility = android.view.View.GONE
                showMoreLink.visibility = android.view.View.GONE
            }
        } else {
            showName.visibility = android.view.View.VISIBLE
            // Update show name
            showName.text = show.title.ifEmpty { "BBC Radio" }
            // Ensure the action bar shows the radio station name when not a podcast
            supportActionBar?.title = station?.title ?: "BBC Radio"

            // Prefer subtitle (secondary/tertiary) in the large headline and show the
            // song/episode title in the smaller line — avoid duplicates.
            val subtitle = listOfNotNull(show.secondary?.takeIf { it.isNotBlank() }, show.tertiary?.takeIf { it.isNotBlank() }).joinToString(" - ").takeIf { it.isNotBlank() }
            val songTitle = show.episodeTitle?.takeIf { it.isNotBlank() }

            if (!subtitle.isNullOrEmpty()) {
                episodeTitle.text = subtitle
                episodeTitle.visibility = android.view.View.VISIBLE
            } else if (!songTitle.isNullOrEmpty()) {
                episodeTitle.text = songTitle
                episodeTitle.visibility = android.view.View.VISIBLE
            } else {
                episodeTitle.visibility = android.view.View.GONE
            }

            // Per product request: do not show the smaller subtitle line for live radio
            // (keep full-screen surface clean). Always hide the small `artistTrack` and
            // the 'show more' affordance for non-podcast/live playback.
            artistTrack.visibility = android.view.View.GONE
            showMoreLink.visibility = android.view.View.GONE
        }
        
        // Load new artwork - use image_url if available and valid, otherwise station logo
        val artworkUrl = if (!show.imageUrl.isNullOrEmpty() && show.imageUrl.startsWith("http")) {
            show.imageUrl
        } else {
            PlaybackStateHelper.getCurrentStation()?.logoUrl
        }
        
        // Only reload if URL changed
        if (artworkUrl != null && artworkUrl != lastArtworkUrl && !isFinishing && !isDestroyed) {
            lastArtworkUrl = artworkUrl
            val fallbackUrl = PlaybackStateHelper.getCurrentStation()?.logoUrl
            
            Glide.with(this)
                .load(artworkUrl)
                .placeholder(android.R.color.transparent)
                .error(Glide.with(this).load(fallbackUrl))
                .listener(object : RequestListener<Drawable> {
                    override fun onLoadFailed(e: GlideException?, model: Any?, target: Target<Drawable>?, isFirstResource: Boolean): Boolean {
                        return false
                    }

                    override fun onResourceReady(resource: Drawable?, model: Any?, target: Target<Drawable>?, dataSource: DataSource?, isFirstResource: Boolean): Boolean {
                        if (resource is BitmapDrawable && isPlaceholderImage(resource.bitmap)) {
                            stationArtwork.post {
                                Glide.with(this@NowPlayingActivity)
                                    .load(fallbackUrl)
                                    .into(stationArtwork)
                            }
                            return true
                        }
                        return false
                    }
                })
                .into(stationArtwork)
        }

            updateProgressUi()
            // Ensure the app-bar overflow menu reflects current podcast / episode state
            invalidateOptionsMenu()
        }

        override fun onCreateOptionsMenu(menu: android.view.Menu): Boolean {
            menuInflater.inflate(R.menu.now_playing_menu, menu)
            return true
        }

        override fun onPrepareOptionsMenu(menu: android.view.Menu): Boolean {
            try {
                val station = PlaybackStateHelper.getCurrentStation()
                val isPodcastStation = station?.id?.startsWith("podcast_") == true

                // Determine podcast id (support preview mode too)
                val podcastId: String? = when {
                    isPodcastStation -> station?.id?.removePrefix("podcast_")
                    previewEpisodeProp != null -> previewEpisodeProp?.podcastId
                    else -> null
                }

                // Share: only show when we have an episode
                val episodeId = previewEpisodeProp?.id ?: PlaybackStateHelper.getCurrentEpisodeId() ?: currentShownEpisodeId
                val shareItem = menu.findItem(R.id.action_share)
                shareItem.isVisible = !episodeId.isNullOrEmpty()

                // Subscribe / Unsubscribe: only show for podcast context
                val subscribeItem = menu.findItem(R.id.action_subscribe)
                if (podcastId != null) {
                    subscribeItem.isVisible = true
                    val subscribed = PodcastSubscriptions.isSubscribed(this, podcastId)
                    subscribeItem.title = if (subscribed) "Unsubscribe" else "Subscribe"
                } else {
                    subscribeItem.isVisible = false
                }

                // Mark as played / unplayed: show only when we have an episode id (preview or playing)
                val markItem = menu.findItem(R.id.action_mark_played)
                if (!episodeId.isNullOrEmpty()) {
                    markItem.isVisible = true
                    val played = PlayedEpisodesPreference.isPlayed(this, episodeId)
                    markItem.title = if (played) "Mark as unplayed" else "Mark as played"
                } else {
                    markItem.isVisible = false
                }
            } catch (e: Exception) {
                android.util.Log.w("NowPlayingActivity", "onPrepareOptionsMenu failed: ${'$'}{e.message}")
            }
            return super.onPrepareOptionsMenu(menu)
        }

        override fun onOptionsItemSelected(item: android.view.MenuItem): Boolean {
            try {
                when (item.itemId) {
                    android.R.id.home -> {
                        onSupportNavigateUp()
                        return true
                    }

                    R.id.action_share -> {
                        // Get current episode and podcast info
                        val episode = previewEpisodeProp ?: run {
                            // Build episode from current playback state
                            val episodeId = PlaybackStateHelper.getCurrentEpisodeId() ?: currentShownEpisodeId
                            if (episodeId.isNullOrEmpty()) return true
                            
                            Episode(
                                id = episodeId,
                                title = episodeTitle.text?.toString() ?: "Episode",
                                description = fullDescriptionHtml.ifEmpty { showName.text?.toString() ?: "" },
                                audioUrl = "",
                                imageUrl = lastArtworkUrl ?: "",
                                pubDate = releaseDateView.text?.toString() ?: "",
                                durationMins = 0,
                                podcastId = ""
                            )
                        }
                        
                        val podcastTitle = supportActionBar?.title?.toString() 
                            ?: showName.text?.toString() 
                            ?: "BBC Radio Player"
                        
                        ShareUtil.shareEpisode(this, episode, podcastTitle)
                        return true
                    }

                    R.id.action_subscribe -> {
                        // Determine podcast id (preview or playing)
                        val station = PlaybackStateHelper.getCurrentStation()
                        val podcastId = when {
                            station != null && station.id.startsWith("podcast_") -> station.id.removePrefix("podcast_")
                            previewEpisodeProp != null -> previewEpisodeProp?.podcastId
                            else -> null
                        }
                        podcastId?.let { pid ->
                            PodcastSubscriptions.toggleSubscription(this, pid)
                            val now = PodcastSubscriptions.isSubscribed(this, pid)
                            // Prefer explicit station/podcast sources for the display name; fall back safely
                            var podcastName = PlaybackStateHelper.getCurrentStation()?.title
                                ?: supportActionBar?.title?.toString()
                                ?: "Podcast"
                            podcastName = podcastName?.takeIf { it.isNotBlank() } ?: "Podcast"
                            // Guard against accidental template literals appearing in the title
                            if (podcastName.contains("${'$'}{")) podcastName = "Podcast"
                            val msg = if (now) "Subscribed to $podcastName" else "Unsubscribed from $podcastName"
                            com.google.android.material.snackbar.Snackbar.make(findViewById(android.R.id.content), msg, com.google.android.material.snackbar.Snackbar.LENGTH_SHORT)
                                .setAnchorView(findViewById(R.id.playback_controls))
                                .show()
                            updateUI()
                            invalidateOptionsMenu()
                        }
                        return true
                    }

                    R.id.action_mark_played -> {
                        val episodeId = previewEpisodeProp?.id ?: PlaybackStateHelper.getCurrentEpisodeId() ?: currentShownEpisodeId
                        if (!episodeId.isNullOrEmpty()) {
                            val nowPlayed = PlayedEpisodesPreference.isPlayed(this, episodeId)
                            if (nowPlayed) {
                                PlayedEpisodesPreference.markUnplayed(this, episodeId)
                                com.google.android.material.snackbar.Snackbar.make(findViewById(android.R.id.content), "Marked as unplayed", com.google.android.material.snackbar.Snackbar.LENGTH_SHORT)
                                    .setAnchorView(findViewById(R.id.playback_controls))
                                    .show()
                            } else {
                                PlayedEpisodesPreference.markPlayed(this, episodeId)
                                com.google.android.material.snackbar.Snackbar.make(findViewById(android.R.id.content), "Marked as played", com.google.android.material.snackbar.Snackbar.LENGTH_SHORT)
                                    .setAnchorView(findViewById(R.id.playback_controls))
                                    .show()
                            }
                            updateUI()
                            invalidateOptionsMenu()
                        }
                        return true
                    }
                }
            } catch (e: Exception) {
                android.util.Log.w("NowPlayingActivity", "onOptionsItemSelected error: ${'$'}{e.message}")
            }
            return super.onOptionsItemSelected(item)
        }

    
    private fun isPlaceholderImage(bitmap: Bitmap): Boolean {
        val width = bitmap.width
        val height = bitmap.height
        
        // Check for 1x1 placeholder
        if (width == 1 && height == 1) return true
        
        if (width < 10 || height < 10) return false
        
        // Sample 5 points: corners and center
        val p1 = bitmap.getPixel(5, 5)
        val p2 = bitmap.getPixel(width - 5, 5)
        val p3 = bitmap.getPixel(5, height - 5)
        val p4 = bitmap.getPixel(width - 5, height - 5)
        val p5 = bitmap.getPixel(width / 2, height / 2)
        
        val pixels = listOf(p1, p2, p3, p4, p5)
        val first = pixels[0]
        
        // Check if all sampled pixels are similar to the first one
        for (p in pixels) {
            if (!areColorsSimilar(first, p)) return false
        }
        
        // Check if the color is grey-ish (R ~= G ~= B)
        return isGrey(first)
    }
    
    private fun areColorsSimilar(c1: Int, c2: Int): Boolean {
        val r1 = (c1 shr 16) and 0xFF
        val g1 = (c1 shr 8) and 0xFF
        val b1 = c1 and 0xFF
        
        val r2 = (c2 shr 16) and 0xFF
        val g2 = (c2 shr 8) and 0xFF
        val b2 = c2 and 0xFF
        
        val diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2)
        return diff < 30 // Tolerance
    }
    
    private fun isGrey(color: Int): Boolean {
        val r = (color shr 16) and 0xFF
        val g = (color shr 8) and 0xFF
        val b = color and 0xFF
        
        // Grey means R, G, and B are close to each other
        val maxDiff = Math.max(Math.abs(r - g), Math.max(Math.abs(r - b), Math.abs(g - b)))
        return maxDiff < 20
    }

    private fun stopPlayback() {
        val intent = Intent(this, RadioService::class.java).apply {
            action = RadioService.ACTION_STOP
        }
        startService(intent)
        finish()
    }

    private fun skipToPrevious() {
        val station = PlaybackStateHelper.getCurrentStation()
        if (station?.id?.startsWith("podcast_") == true) {
            val intent = Intent(this, RadioService::class.java).apply {
                action = RadioService.ACTION_SEEK_DELTA
                putExtra(RadioService.EXTRA_SEEK_DELTA, -10_000L)
            }
            startService(intent)
        } else {
            val intent = Intent(this, RadioService::class.java).apply {
                action = RadioService.ACTION_SKIP_TO_PREVIOUS
            }
            startService(intent)
        }
    }

    private fun skipToNext() {
        val station = PlaybackStateHelper.getCurrentStation()
        if (station?.id?.startsWith("podcast_") == true) {
            val intent = Intent(this, RadioService::class.java).apply {
                action = RadioService.ACTION_SEEK_DELTA
                putExtra(RadioService.EXTRA_SEEK_DELTA, 30_000L)
            }
            startService(intent)
        } else {
            val intent = Intent(this, RadioService::class.java).apply {
                action = RadioService.ACTION_SKIP_TO_NEXT
            }
            startService(intent)
        }
    }

    private fun togglePlayPause() {
        val isCurrentlyPlaying = PlaybackStateHelper.getIsPlaying()
        PlaybackStateHelper.setIsPlaying(!isCurrentlyPlaying)
        
        val intent = Intent(this, RadioService::class.java).apply {
            action = if (isCurrentlyPlaying) {
                RadioService.ACTION_PAUSE
            } else {
                RadioService.ACTION_PLAY
            }
        }
        startService(intent)
        updateUI()
    }

    private fun toggleFavorite() {
        // Prefer episode-save (bookmark) whenever an episode is in context (playing or preview).
        val station = PlaybackStateHelper.getCurrentStation()
        val episodeIdInPlayback = PlaybackStateHelper.getCurrentEpisodeId()
        val episodeId = previewEpisodeProp?.id ?: episodeIdInPlayback ?: currentShownEpisodeId

        if (!episodeId.isNullOrEmpty()) {
            // Construct Episode object when necessary (previewEpisodeProp may already be available)
            val episode = previewEpisodeProp ?: Episode(
                id = episodeId,
                title = PlaybackStateHelper.getCurrentShow().episodeTitle ?: PlaybackStateHelper.getCurrentShow().title ?: "Saved episode",
                description = PlaybackStateHelper.getCurrentShow().description ?: "",
                audioUrl = "",
                imageUrl = PlaybackStateHelper.getCurrentShow().imageUrl ?: "",
                pubDate = "",
                durationMins = 0,
                podcastId = (station?.id?.removePrefix("podcast_") ?: previewEpisodeProp?.podcastId).orEmpty()
            )
            val podcastTitle = PlaybackStateHelper.getCurrentStation()?.title ?: supportActionBar?.title?.toString() ?: "Podcast"
            val nowSaved = SavedEpisodes.toggleSaved(this, episode, podcastTitle)
            val msg = if (nowSaved) "Saved episode: ${episode.title}" else "Removed saved episode: ${episode.title}"
            com.google.android.material.snackbar.Snackbar.make(findViewById(android.R.id.content), msg, com.google.android.material.snackbar.Snackbar.LENGTH_SHORT)
                .setAnchorView(findViewById(R.id.playback_controls))
                .show()
            // Immediately reflect saved state in the UI (bookmark icon)
            favoriteButton.icon = ContextCompat.getDrawable(this, if (nowSaved) R.drawable.ic_bookmark else R.drawable.ic_bookmark_outline)
            favoriteButton.iconTint = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.md_theme_primary))
            favoriteButton.setBackgroundColor(if (nowSaved) ContextCompat.getColor(this, R.color.md_theme_primaryContainer) else android.graphics.Color.TRANSPARENT)
            updateUI()
            return
        }

        // No episode in context — fall back to station/podcast favorite/subscription behavior
        if (station != null) {
            if (station.id.startsWith("podcast_")) {
                val podcastId = station.id.removePrefix("podcast_")
                PodcastSubscriptions.toggleSubscription(this, podcastId)
                val now = PodcastSubscriptions.isSubscribed(this, podcastId)
                val podcastName = station.title
                val msg = if (now) "Subscribed to ${podcastName}" else "Unsubscribed from ${podcastName}"
                com.google.android.material.snackbar.Snackbar.make(findViewById(android.R.id.content), msg, com.google.android.material.snackbar.Snackbar.LENGTH_SHORT)
                    .setAnchorView(findViewById(R.id.playback_controls))
                    .show()
            } else {
                FavoritesPreference.toggleFavorite(this, station.id)
            }
            updateUI()
            return
        }

        // If we reach here and previewEpisodeProp exists (defensive), handle it as episode-save
        val preview = previewEpisodeProp
        if (preview != null) {
            val nowSaved = SavedEpisodes.toggleSaved(this, preview, supportActionBar?.title?.toString().orEmpty())
            val msg = if (nowSaved) "Saved episode: ${preview.title}" else "Removed saved episode: ${preview.title}"
            com.google.android.material.snackbar.Snackbar.make(findViewById(android.R.id.content), msg, com.google.android.material.snackbar.Snackbar.LENGTH_SHORT)
                .setAnchorView(findViewById(R.id.playback_controls))
                .show()
            favoriteButton.icon = ContextCompat.getDrawable(this, if (nowSaved) R.drawable.ic_bookmark else R.drawable.ic_bookmark_outline)
            favoriteButton.iconTint = ColorStateList.valueOf(ContextCompat.getColor(this, R.color.md_theme_primary))
            favoriteButton.setBackgroundColor(if (nowSaved) ContextCompat.getColor(this, R.color.md_theme_primaryContainer) else android.graphics.Color.TRANSPARENT)
        }
    }

    private fun startPlaybackStateUpdates() {
        stopPlaybackStateUpdates()
        updateTimer = Thread {
            while (!Thread.currentThread().isInterrupted) {
                try {
                    Thread.sleep(500) // Update every 500ms
                    if (!isFinishing && !isDestroyed) {
                        runOnUiThread { updateUI() }
                    }
                } catch (e: InterruptedException) {
                    break
                }
            }
        }
        updateTimer?.start()
    }

    private fun stopPlaybackStateUpdates() {
        updateTimer?.interrupt()
        updateTimer = null
    }

    private fun showFullDescription() {
        val title = episodeTitle.text?.toString()?.takeIf { it.isNotEmpty() } ?: "Episode Description"
        val dialog = EpisodeDescriptionDialogFragment.newInstance(fullDescriptionHtml, title, lastArtworkUrl)
        dialog.show(supportFragmentManager, "episode_description")
    }

    private fun updateMarkPlayedButtonState() {
        // The mark-as-played control is intentionally hidden from the app bar to avoid duplication with
        // the main star subscription action. Keep it GONE so it does not display in the app bar.
        markPlayedButton.visibility = android.view.View.GONE
    }
}